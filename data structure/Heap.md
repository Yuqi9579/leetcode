# 常见数据结构

## 1. 堆

堆是用数组实现的二叉树。

### 1.1 堆的属性

堆分为最大堆和最小堆，在最大队中，父节点的只比么诶一个子节点都要大，在最小堆中类比最大堆。  
最大堆总是将其中的最大值存放在根节点，最小堆类比。这种属性可以访问最重要的元素，因此常被当做优先队列。
> **注意:** 除开根节点，其他节点的大小顺序是未知的。比如在一个最大堆中，最大的元素总是位于index 0，但是最小的元素未必就在最末的节点，但是一定在叶子节点，只是所在的深度不确定。

### 1.2 堆的实现

#### 1.2.1 与普通树的区别

**节点顺序：** 在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。  

**内存占用：** 普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。  

**平衡：** 二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(logn)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(logn) 的性能。  

**搜索：** 在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。

#### 1.2.2 实现

用数组来实现堆，[10,7,2,5,1]
parent(i) = floor((i-1)/2)
left(i) = 2i + 1
right(i) = 2i + 2
|Node |Array index(i) |Parent index |Left child |Right child|
|-----|---------------|-------------|-----------|-----------|
|10   |0              |-1           |1          |2          |
|7    |1              |0            |3          |4          |
|2    |2              |0            |5          |6          |
|5    |3              |1            |7          |8          |
|1    |4              |1            |9          |10         |
对于最大堆，appay[parent(i)] >= array[i]
用堆会比用二叉树节省空间因为没用额外指针，但是搜索的开销会变大。在数组中，父节点的索引总是在子节点的前面，所以必须将树的一层填满才能填下一层，这与二叉树有点不同，二叉树的叶子节点可以出现在任何一层，而堆中只能出现在最后一层和倒数第二层。
>**注意:** 一个有序数组一定是一个最大堆或者最小堆，反之不成立，要将堆转化为有序数组需要堆排序。
树的高度是指从树的根节点到最低叶节点所需要的步数，一个高度为h的堆有h+1层。如果一个堆有n个节点，那么它的高度是floor(log2(n))。每一个填满的层高度是h，有2\^h个节点，前面的节点总数是2\^h-1。

#### 1.2.3 操作

- `shiftup()`: 如果一个节点比它的父节点大(max_heap)，或小(min_heap)，那么需要将它和父节点交换位置，位置会在树结构中上升。  
- `shiftdown()`: 如果一个节点比它的子节点小(max_heap)，或大(min_heap)，那么需要将它向下移动，位置会在树结构中下降。

##### 插入

